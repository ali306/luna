#!/usr/bin/env python3

import logging
import sys
from typing import Any, List, Optional

import numpy as np

from config import DEFAULT_TTS_VOICE
from exceptions import TTSEngineUnavailableError, TTSGenerationError
from models.schemas import TTSRequest
from state import app_state
from utils.resource_utils import setup_bundled_paths

logger = logging.getLogger(__name__)


class TTSGenerator:
    """Handles TTS text-to-speech generation using Kokoro engine"""

    def __init__(self):
        self.engine: Optional[Any] = None
        self.engine_type: Optional[str] = None

    def initialize_engine(self) -> None:
        """Initialize the Kokoro TTS engine"""
        try:
            logger.info("Initializing Kokoro TTS engine...")

            if getattr(sys, "frozen", False):
                setup_bundled_paths()

            from kokoro import KPipeline

            self.engine = KPipeline(lang_code="a")
            self.engine_type = "kokoro"

            self._update_app_state()
            logger.info("Kokoro TTS engine initialized successfully")

        except Exception as e:
            logger.error(f"Failed to initialize Kokoro TTS: {e}")
            self._clear_app_state()
            raise TTSEngineUnavailableError(
                "TTS engine could not be initialized", original_error=e
            )

    def generate_audio(self, request: TTSRequest) -> np.ndarray:
        """Generate audio from text using Kokoro TTS"""
        if not self.is_available():
            raise TTSEngineUnavailableError("TTS engine is not available")

        try:
            voice = self._get_voice_parameter(request.voice)
            speed = request.speed or 1.0

            audio_segments = self._generate_audio_segments(request.text, voice, speed)
            return self._concatenate_audio_segments(audio_segments)

        except TTSGenerationError:
            raise
        except Exception as e:
            raise TTSGenerationError(
                "Failed to generate audio with Kokoro TTS",
                error_code="generation_failed",
                original_error=e,
            )

    def is_available(self) -> bool:
        """Check if TTS engine is available"""
        return self.engine is not None

    def get_engine_info(self) -> dict:
        """Get information about the TTS engine"""
        return {
            "engine_type": self.engine_type or "none",
            "status": "loaded" if self.is_available() else "not loaded",
        }

    def _get_voice_parameter(self, voice: Optional[str]) -> str:
        """Get the voice parameter, using default if not specified"""
        return voice if voice and voice != "default" else DEFAULT_TTS_VOICE

    def _generate_audio_segments(
        self, text: str, voice: str, speed: float
    ) -> List[Any]:
        """Generate audio segments from text"""
        try:
            generator = self.engine(
                text, voice=voice, speed=speed, split_pattern=r"\n\n+"
            )

            audio_segments = [audio for (_, _, audio) in generator]
            if not audio_segments:
                raise TTSGenerationError(
                    "No audio generated by Kokoro", error_code="empty_generation"
                )

            return audio_segments

        except Exception as e:
            if isinstance(e, TTSGenerationError):
                raise
            raise TTSGenerationError(
                "Failed to generate audio segments",
                error_code="segment_generation_failed",
                original_error=e,
            )

    def _concatenate_audio_segments(self, audio_segments: List[Any]) -> np.ndarray:
        """Concatenate audio segments into a single array"""
        try:
            if audio_segments:
                audio_arrays = [
                    np.asarray(audio, dtype=np.float32) for audio in audio_segments
                ]
                return np.concatenate(audio_arrays)
            else:
                return np.array([], dtype=np.float32)
        except Exception as e:
            raise TTSGenerationError(
                "Failed to concatenate audio segments",
                error_code="concatenation_failed",
                original_error=e,
            )

    def _update_app_state(self) -> None:
        """Update application state with engine information"""
        app_state.tts_engine = self.engine
        app_state.tts_engine_type = self.engine_type

    def _clear_app_state(self) -> None:
        """Clear engine information from application state"""
        self.engine = None
        self.engine_type = None
        app_state.tts_engine = None
        app_state.tts_engine_type = None
